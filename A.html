<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>OTFフォント パスデータ反転プレビュー</title>
<script src="https://cdn.jsdelivr.net/npm/opentype.js@1.3.4/dist/opentype.min.js"></script>
<style>
  body { font-family: sans-serif; margin: 20px; }
  canvas { border: 1px solid #333; margin-top: 20px; }
</style>
</head>
<body>

<h1>OTFフォント パスデータ反転プレビュー</h1>

<label for="fontUrl">フォントファイルのURL：</label><br>
<input type="text" id="fontUrl" style="width: 100%;" placeholder="例: https://example.com/fonts/myfont.otf"><br>
<button id="loadFont">フォント読み込み</button><br><br>

<label for="inputText">文字列：</label>
<input type="text" id="inputText" value="ABC" style="width: 300px;"><br><br>

<label><input type="checkbox" id="reversePath"> 輪郭データを数学的に反転</label><br><br>

<canvas id="canvas" width="600" height="300"></canvas>

<script>
  const fontUrlInput = document.getElementById('fontUrl');
  const loadBtn = document.getElementById('loadFont');
  const inputText = document.getElementById('inputText');
  const reversePath = document.getElementById('reversePath');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  let font = null;

  loadBtn.addEventListener('click', () => {
    const url = fontUrlInput.value.trim();
    if (!url) {
      alert('URLを入力してください');
      return;
    }

    opentype.load(url, (err, loadedFont) => {
      if (err) {
        alert('フォント読み込み失敗：' + err);
        return;
      }
      font = loadedFont;
      draw();
    });
  });

  inputText.addEventListener('input', draw);
  reversePath.addEventListener('change', draw);

  function reversePathData(originalCommands) {
    const reversed = [];
    let subPath = [];

    for (let cmd of originalCommands) {
      subPath.push(cmd);
      if (cmd.type === 'Z') {
        reversed.push(...reverseSubPath(subPath));
        subPath = [];
      }
    }
    if (subPath.length) {
      reversed.push(...reverseSubPath(subPath));
    }
    return reversed;
  }

  function reverseSubPath(commands) {
    const reversed = [];
    const points = [];

    for (let cmd of commands) {
      if (cmd.x !== undefined && cmd.y !== undefined) {
        points.push({ x: cmd.x, y: cmd.y });
      }
    }
    points.reverse();

    for (let i = 0; i < points.length; i++) {
      const p = points[i];
      if (i === 0) {
        reversed.push({ type: 'M', x: p.x, y: p.y });
      } else {
        reversed.push({ type: 'L', x: p.x, y: p.y });
      }
    }
    reversed.push({ type: 'Z' });

    return reversed;
  }

  function draw() {
    if (!font) return;

    const text = inputText.value || 'A';
    const fontSize = 150;
    const xStart = 20;
    const y = 200;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    let x = xStart;
    for (let char of text) {
      const glyph = font.charToGlyph(char);
      let path = glyph.getPath(x, y, fontSize);

      if (reversePath.checked) {
        const reversedCommands = reversePathData(path.commands);
        path.commands = reversedCommands;
      }

      ctx.beginPath();
      for (let cmd of path.commands) {
        if (cmd.type === 'M') ctx.moveTo(cmd.x, cmd.y);
        else if (cmd.type === 'L') ctx.lineTo(cmd.x, cmd.y);
        else if (cmd.type === 'C') ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
        else if (cmd.type === 'Q') ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
        else if (cmd.type === 'Z') ctx.closePath();
      }
      ctx.fill();

      x += glyph.advanceWidth * (fontSize / font.unitsPerEm) * 0.9;
    }
  }
</script>

</body>
</html>
