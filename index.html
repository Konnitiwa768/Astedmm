<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVG to Font Converter</title>
</head>
<body>
    <h1>SVG to Font Converter</h1>
    
    <input type="file" id="svgFiles" webkitdirectory multiple accept=".svg">
    <button id="convertButton">フォントに変換してダウンロード</button>
    <div id="fileList"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/opentype.js/0.6.5/opentype.min.js" integrity="sha512-bRz6QInwm6Dnvgt0oVNbSjs0eyLXmAttb8t/jZWbBTTnUrs0O3HtNYE6pf3K0gO5RwUJZ50OzJcIiYi8lWj7EA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
        const fileListDiv = document.getElementById('fileList');
        const glyphs = [];
        let fontSlot = 0x4E00; // Unicodeの開始点

        document.getElementById('svgFiles').addEventListener('change', function () {
            fileListDiv.innerHTML = ''; // アップロードされたファイルリストをリセット
            Array.from(this.files).forEach(file => {
                const listItem = document.createElement('div');
                listItem.textContent = file.name;
                fileListDiv.appendChild(listItem);
            });
        });

        document.getElementById('convertButton').addEventListener('click', function () {
            const input = document.getElementById('svgFiles');
            const files = input.files;

            if (files.length === 0) {
                alert('SVGファイルを選択してください');
                return;
            }

            let filesProcessed = 0;

            Array.from(files).forEach(file => {
                if (file.type === "image/svg+xml") {
                    const reader = new FileReader();
                    reader.onload = function (event) {
                        const svgData = event.target.result;

                        try {
                            const parser = new DOMParser();
                            const svgDoc = parser.parseFromString(svgData, "image/svg+xml");
                            const svgElement = svgDoc.querySelector('svg');

                            if (!svgElement) {
                                console.error(`ファイル ${file.name} に <svg> 要素が見つかりません`);
                                return;
                            }

                            const paths = [];
                            svgElement.querySelectorAll('line, circle, rect, path').forEach(child => {
                                let pathData = '';
                                switch (child.tagName) {
                                    case 'line':
                                        const x1 = parseFloat(child.getAttribute("x1"));
                                        const y1 = parseFloat(child.getAttribute("y1"));
                                        const x2 = parseFloat(child.getAttribute("x2"));
                                        const y2 = parseFloat(child.getAttribute("y2"));
                                        pathData = `M${x1},${y1} L${x2},${y2}`;
                                        break;
                                    case 'circle':
                                        const cx = parseFloat(child.getAttribute("cx"));
                                        const cy = parseFloat(child.getAttribute("cy"));
                                        const r = parseFloat(child.getAttribute("r"));
                                        pathData = `M${cx - r},${cy} A${r},${r} 0 1,0 ${cx + r},${cy} A${r},${r} 0 1,0 ${cx - r},${cy} Z`;
                                        break;
                                    case 'rect':
                                        const x = parseFloat(child.getAttribute("x"));
                                        const y = parseFloat(child.getAttribute("y"));
                                        const width = parseFloat(child.getAttribute("width"));
                                        const height = parseFloat(child.getAttribute("height"));
                                        pathData = `M${x},${y} H${x + width} V${y + height} H${x} Z`;
                                        break;
                                    case 'path':
                                        pathData = child.getAttribute('d');
                                        break;
                                    default:
                                        console.warn(`未対応の要素: ${child.tagName}`);
                                        return;
                                }
                                if (pathData) paths.push(pathData);
                            });

                            // パスデータから1つのパスにまとめる
                            const fullPath = paths.join(" ");
                            const opentypePath = parseSVGPath(fullPath); // SVGパスをパースするカスタム関数を使用

                            // グリフを作成
                            const glyph = new opentype.Glyph({
                                name: file.name.split('.')[0],
                                unicode: fontSlot++, 
                                advanceWidth: 1000,
                                path: opentypePath
                            });

                            glyphs.push(glyph);
                        } catch (error) {
                            console.error(`ファイル ${file.name} の処理中にエラーが発生しました:`, error);
                        }

                        filesProcessed++;
                        if (filesProcessed === files.length) {
                            createFont(glyphs);
                        }
                    };
                    reader.readAsText(file);
                } else {
                    filesProcessed++;
                }
            });
        });

        function createFont(glyphs) {
            if (glyphs.length === 0) {
                alert("フォントを作成するためのSVGファイルが見つかりませんでした。");
                return;
            }

            const font = new opentype.Font({
                familyName: 'CustomFont',
                styleName: 'Regular',
                unitsPerEm: 1000,
                ascender: 800, // 必須プロパティ
                descender: -200, // 必須プロパティ
                glyphs: glyphs
            });

            // フォントデータをバイナリに変換し、Blobを生成
            const fontData = font.toArrayBuffer();
            const blob = new Blob([fontData], { type: 'font/ttf' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'custom_font.ttf';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function parseSVGPath(pathData) {
            const path = new opentype.Path();
            const commands = pathData.split(/(?=[MLAHSQCTZ])/); // コマンドで分割

            let currentX = 0;
            let currentY = 0;

            commands.forEach(command => {
                const type = command[0];
                const args = command.slice(1).trim().split(/[\s,]+/).map(Number);

                switch (type) {
                    case 'M': // Move to
                        currentX = args[0];
                        currentY = args[1];
                        path.moveTo(currentX, currentY);
                        break;
                    case 'L': // Line to
                        currentX = args[0];
                        currentY = args[1];
                        path.lineTo(currentX, currentY);
                        break;
                    case 'H': // Horizontal line to
                        currentX = args[0];
                        path.lineTo(currentX, currentY);
                        break;
                    case 'V': // Vertical line to
                        currentY = args[0];
                        path.lineTo(currentX, currentY);
                        break;
                    case 'C': // Cubic Bezier curve
                        path.bezierCurveTo(args[0], args[1], args[2], args[3], args[4], args[5]);
                        currentX = args[4];
                        currentY = args[5];
                        break;
                    case 'Q': // Quadratic Bezier curve (相対コマンド)
                        const qX1 = currentX + args[0];
                        const qY1 = currentY + args[1];
                        const qX2 = currentX + args[2];
                        const qY2 = currentY + args[3];
                        path.quadraticCurveTo(qX1, qY1, qX2, qY2);
                        currentX = qX2;
                        currentY = qY2;
                        break;
                    case 'A': // Arc (相対コマンド)
                        const rx = args[0]; // x軸半径
                        const ry = args[1]; // y軸半径
                        const xAxisRotation = args[2]; // x軸回転角
                        const largeArcFlag = args[3]; // 大弧フラグ
                        const sweepFlag = args[4]; // スイープフラグ
                        const x = currentX + args[5]; // 終点x
                        const y = currentY + args[6]; // 終点y

                        // 円弧を描く
                        const startX = currentX;
                        const startY = currentY;

                        const angle = xAxisRotation * (Math.PI / 180); // ラジアンに変換
                        const sinAngle = Math.sin(angle);
                        const cosAngle = Math.cos(angle);

                        // 変換行列を適用して座標を計算
                        const x1 = cosAngle * (startX - x) / 2 + sinAngle * (startY - y) / 2;
                        const y1 = -sinAngle * (startX - x) / 2 + cosAngle * (startY - y) / 2;

                        // 縦半径と横半径を適用
                        const rx2 = rx * rx;
                        const ry2 = ry * ry;
                        const x1x1 = x1 * x1;
                        const y1y1 = y1 * y1;
                        const radiiCheck = x1x1 / rx2 + y1y1 / ry2;

                        if (radiiCheck > 1) {
                            // 半径を調整
                            rx = Math.sqrt(radiiCheck) * rx;
                            ry = Math.sqrt(radiiCheck) * ry;
                        }

                        const centerX = (startX + x) / 2;
                        const centerY = (startY + y) / 2;

                        // 円弧のコントロールポイントを計算
                        const ux = (startX - centerX) / rx;
                        const uy = (startY - centerY) / ry;
                        const vx = (x - centerX) / rx;
                        const vy = (y - centerY) / ry;

                        const q = (ux * ux + uy * uy) ** 0.5;
                        const p = (vx * vx + vy * vy) ** 0.5;

                        const angleStart = Math.atan2(uy, ux);
                        const angleEnd = Math.atan2(vy, vx);
                        let deltaAngle = angleEnd - angleStart;

                        if (largeArcFlag === 1 && deltaAngle < 0) {
                            deltaAngle += Math.PI * 2;
                        } else if (largeArcFlag === 0 && deltaAngle > 0) {
                            deltaAngle -= Math.PI * 2;
                        }

                        // 円弧を描く
                        const steps = 10; // 分割数
                        for (let i = 0; i <= steps; i++) {
                            const t = i / steps;
                            const angleCurrent = angleStart + t * deltaAngle;
                            const xCurrent = centerX + rx * Math.cos(angleCurrent) * cosAngle - ry * Math.sin(angleCurrent) * sinAngle;
                            const yCurrent = centerY + rx * Math.cos(angleCurrent) * sinAngle + ry * Math.sin(angleCurrent) * cosAngle;

                            if (i === 0) {
                                path.moveTo(xCurrent, yCurrent);
                            } else {
                                path.lineTo(xCurrent, yCurrent);
                            }
                        }

                        currentX = x;
                        currentY = y;
                        break;
                    case 'Z': // Close path
                        path.close();
                        break;
                    default:
                        console.warn(`未対応のコマンド: ${type}`);
                        break;
                }
            });

            return path;
        }
    </script>
</body>
</html>
